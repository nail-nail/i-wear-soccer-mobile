# i_wear_soccer

## Tugas 7
### Jelaskan apa itu widget tree pada Flutter dan bagaimana hubungan parent-child (induk-anak) bekerja antar widget.
    Widget tree adalah representasi dari semua widget UI yang menyusun aplikasi Flutter, di mana setiap widget diwakili sebuah node. Cara kerja hubungan parent-child antar widget yaitu induk memberikan batasan (constraints), seperti ukuran minimum atau maksimum, kepada widget anaknya. Widget anak kemudian menentukan ukurannya sendiri berdasarkan batasan tersebut dan menyampaikannya kembali ke induk. Akhirnya, widget induk yang memutuskan posisi pasti dari anak-anaknya di layar.
    
### Sebutkan semua widget yang kamu gunakan dalam proyek ini dan jelaskan fungsinya.
    Dalam proyek ini, saya menggunakan widget: MyApp sebagai root yang membentuk MaterialApp bertema biru, lalu MyHomePage yang menyiapkan Scaffold lengkap dengan AppBar berjudul "I Wear Soccer” yang di dalamnya ada baris InfoCard yang menampilkan data profil dalam Card dan Container bersistem Column. Ada juga ItemCard yang dibalut Material dan InkWell untuk efek sentuh, menampilkan Icon dan Text, serta memicu SnackBar (memunculkan pesan) saat ditekan, sementara widget layout lain seperti Row, Column, Padding, SizedBox, Center, dan Container mengatur penempatan dan jarak antar elemen.

### Apa fungsi dari widget MaterialApp? Jelaskan mengapa widget ini sering digunakan sebagai widget root.
    Widget MaterialApp adalah widget pembungkus utama yang menyediakan fungsionalitas dan styling dasar yang diperlukan untuk aplikasi yang menerapkan Material Design. Widget ini sering digunakan sebagai root (akar) aplikasi karena ia mengatur seluruh struktur navigasi (rute), tema (seperti warna dan font), dan menyediakan konteks untuk widget fundamental lainnya seperti Scaffold. Tanpa MaterialApp, banyak widget standar Material Design tidak akan berfungsi dengan benar karena kekurangan konteks visual dan struktural yang dibutuhkannya.
### Jelaskan perbedaan antara StatelessWidget dan StatefulWidget. Kapan kamu memilih salah satunya?
    StatelessWidget bersifat immutable (tidak dapat diubah), hanya bergantung pada data masukan (input data) dari induknya dan akan di-render ulang hanya jika input tersebut berubah. Sementara itu, StatefulWidget bersifat mutable (dapat diubah) karena memiliki objek State internal yang persisten. Widget ini dapat memperbarui dirinya sendiri secara dinamis sebagai respons terhadap interaksi pengguna atau event lain, bukan hanya karena perubahan input. StatelessWidget lebih baik untuk UI yang statis (seperti teks atau ikon) dan StatefulWidget ketika bagian UI tersebut perlu berubah secara internal selama runtime (seperti checkbox atau form ).
### Apa itu BuildContext dan mengapa penting di Flutter? Bagaimana penggunaannya di metode build?
    BuildContext adalah objek yang diterima sebagai parameter oleh metode build  dan merepresentasikan lokasi sebuah widget di dalam widget tree. BuildContext memungkinkan widget untuk menemukan dan berinteraksi dengan widget leluhurnya (widget lain yang berada di atasnya dalam tree). Dalam metode build, BuildContext digunakan untuk mengambil data atau layanan dari leluhur tersebut, misalnya, untuk mendapatkan data tema saat ini menggunakan Theme.of(context) atau untuk menampilkan SnackBar menggunakan ScaffoldMessenger.of(context)
### Jelaskan konsep "hot reload" di Flutter dan bagaimana bedanya dengan "hot restart".
    Hot reload adalah fitur yang memuat perubahan kode langsung ke Virtual Machine (VM) Dart yang sedang berjalan dan membangun ulang widget tree. Keunggulan utamanya adalah fitur ini mempertahankan state (kondisi) aplikasi saat ini; misalnya, teks yang sudah diketik di form tidak akan hilang. Ini terjadi karena hot reload tidak menjalankan ulang fungsi main() atau initState(). Sebaliknya, hot restart juga memuat perubahan kode ke VM, tetapi ia memulai ulang seluruh aplikasi Flutter, yang berarti state aplikasi akan hilang dan kembali ke kondisi awal.

## Tugas 8
### Jelaskan perbedaan antara Navigator.push() dan Navigator.pushReplacement() pada Flutter. Dalam kasus apa sebaiknya masing-masing digunakan pada aplikasi Football Shop kamu?
    Navigator.push() menambahkan halaman baru ke atas stack tanpa menghilangkan halaman lain yang sudah ada di stack sehingga pengguna bisa kembali ke halaman-halaman sebelumnya dengan tombol back. Di lain sisi, Navigator.pushReplacement() mengganti route aktif sehingga halaman lama dihapus dari stack. Di aplikasi I Wear Soccer, Navigator.push() dipakai saat men-tap kartu “Add Product” agar form terbuka sebagai halaman sementara. Navigator.push() juga cocok digunakan untuk alur sekunder lainnya karena user mungkin mau kembali ke halaman sebelumnya setelah melakukan aksi (seperti ingin kembali ke main page setelah menambahkan produk untuk melihat produk yang ditambahkan). Navigator.pushReplacement() digunakan di drawer I Wear Soccer untuk berpindah antara halaman utama dan form, dan cocok juga digunakan untuk berpindah antar top-level destination supaya tidak ada tumpukan halaman berulang saat user bolak-balik melalui menu samping.

### Bagaimana kamu memanfaatkan hierarchy widget seperti Scaffold, AppBar, dan Drawer untuk membangun struktur halaman yang konsisten di seluruh aplikasi?
    Setiap layar dibangun dengan Scaffold sehingga AppBar, body, dan Drawer konsisten di seluruh aplikasi. AppBar menampilkan detail produk sesuai dengan warna tema, sementara body di-wrap oleh Padding supaya konten tidak menempel ke tepi layar. LeftDrawer dipasang di Scaffold.drawer baik pada Home maupun ProductForm sehingga navigasi utama selalu tersedia. Drawer juga memakai header khusus untuk branding toko.

### Dalam konteks desain antarmuka, apa kelebihan menggunakan layout widget seperti Padding, SingleChildScrollView, dan ListView saat menampilkan elemen-elemen form? Berikan contoh penggunaannya dari aplikasi kamu.
    SingleChildScrollView membungkus seluruh Column form di product_form sehingga semua delapan field dan switch bisa terlihat saat layar kecil. Tanpa ini, keyboard akan menutupi input-input terbawah. Pading digunakan pada TextFormField, dropdown, dan tombol agar form input lebih luas dan mudah dibaca. ListView pada drawer membuat scroll otomatis untuk daftar menu. Pola yang sama dapat diterapkan ketika jumlah elemen form bertambah banyak karena ListView hanya merender widget yang terlihat dan menjaga performa.

### Bagaimana kamu menyesuaikan warna tema agar aplikasi Football Shop memiliki identitas visual yang konsisten dengan brand toko?
    Tema global disetel sekali di lib/main.dart melalui ThemeData(colorScheme: ColorScheme.fromSeed(seedColor: Colors.indigo)). Dengan seed tunggal indigo, Flutter menghasilkan palet warna yang harmonis, lalu seluruh widget yang mengambil Theme.of(context).colorScheme otomatis konsisten dengan brand I Wear Soccer. Komponen inti juga konsisten memakai warna dari skema tersebut dimana AppBar beranda memanggil Theme.of(context).colorScheme.primary (lib/menu.dart), tombol Save pada form memakai Colors.indigo yang masih satu keluarga dengan warna utama.

## Tugas 9
### Jelaskan mengapa kita perlu membuat model Dart saat mengambil/mengirim data JSON? Apa konsekuensinya jika langsung memetakan Map<String, dynamic> tanpa model (terkait validasi tipe, null-safety, maintainability)?
    Model Dart menjadi kontrak eksplisit antara data JSON dan struktur aplikasi sehingga compiler bisa memeriksa tipe field sejak awal. Dengan model, saya hanya perlu memanggil fromJson/toJson dan seluruh parsing plus validasi dasar (misal angka wajib int, tanggal wajib String) terjadi secara otomatis. Kalau saya asal memakai Map<String, dynamic>, semua properti bertipe dynamic sehingga kesalahan seperti salah ketik nama field atau asumsi nullable/non-null baru ketahuan saat runtime dan seringnya membuat crash. Selain rawan null, Map acak juga menyulitkan refactor karena tidak ada satu sumber kebenaran untuk kolom yang valid.

### Apa fungsi package http dan CookieRequest dalam tugas ini? Jelaskan perbedaan peran http vs CookieRequest.
    Package http saya menggunakan untuk request stateless karena hanya perlu method get/post biasa tanpa memikirkan sesi. CookieRequest dari package pbp_django_auth dibungkus supaya secara otomatis menyisipkan dan menyimpan cookie Django (csrftoken + sessionid) sehingga request autentikasi tetap berstatus login. Dengan demikian, http cocok ketika endpoint tidak butuh login, sedangkan CookieRequest dipakai ketika endpoint terlindungi atau membutuhkan CSRF token.

### Jelaskan mengapa instance CookieRequest perlu untuk dibagikan ke semua komponen di aplikasi Flutter.
    CookieRequest menampung state penting seperti cookie sesi, header, dan status login. Kalau tiap widget membuat instance baru, cookie tidak terbawa dan pengguna akan dianggap logout setiap berpindah halaman. Dengan membagikan instance (seperti via Provider), semua komponen memakai sesi yang sama sehingga login hanya sekali, status user konsisten, dan request bisa saling berbagi token tanpa saling tumpang tindih.

### Jelaskan konfigurasi konektivitas yang diperlukan agar Flutter dapat berkomunikasi dengan Django. Mengapa kita perlu menambahkan 10.0.2.2 pada ALLOWED_HOSTS, mengaktifkan CORS dan pengaturan SameSite/cookie, dan menambahkan izin akses internet di Android? Apa yang akan terjadi jika konfigurasi tersebut tidak dilakukan dengan benar?
    Emulator Android mengakses host mesin lewat IP khusus 10.0.2.2 sehingga domain ini wajib dimasukkan ke ALLOWED_HOSTS Django agar request tidak ditolak. Karena Flutter memanggil endpoint lintas origin, backend harus mengaktifkan CORS dan mengizinkan credential (SameSite=None + Secure) supaya cookie sesi/CSRF boleh dikirim. Di sisi Flutter, AndroidManifest perlu android.permission.INTERNET agar request keluar dari aplikasi. Tanpa konfigurasi tersebut, request akan gagal: Django melempar disallowed host, cookie CSRF tidak diterima sehingga login gagal, atau Android sama sekali tidak mengizinkan koneksi sehingga fetch selalu error.

### Jelaskan mekanisme pengiriman data mulai dari input hingga dapat ditampilkan pada Flutter.
    Pengguna mengisi form di Flutter yang dibungkus Form dan TextFormField dan dilakukan validasi lokal terlebih dahulu. Setelah tombol submit dipencet, data dikonversi ke Map lalu ke JSON dan dikirim via http/CookieRequest ke endpoint Django. View Django membaca body, memvalidasi, kemudian menyimpan ke database dan mengembalikan respons JSON berisi objek terbaru/koleksi data. Flutter menerima respons, melakukan jsonDecode, memetakan ke model Dart, lalu state management (setState atau Provider) memperbarui widget sehingga data baru langsung tampil di UI.

### Jelaskan mekanisme autentikasi dari login, register, hingga logout. Mulai dari input data akun pada Flutter ke Django hingga selesainya proses autentikasi oleh Django dan tampilnya menu pada Flutter.
    Alur register dimulai ketika pengguna mengisi username/password di Flutter, lalu CookieRequest.post ke /auth/register/ yang membuat akun baru di Django bila valid. Saat login, form Flutter mengirim credential ke /auth/login/ menggunakan CookieRequest sehingga Django Auth mengecek password, membuat sessionid + csrftoken, dan membalas dengan status sukses beserta cookie yang otomatis disimpan CookieRequest. Flutter kemudian menyetel flag loggedIn dan menavigasi ke menu utama karena Provider CookieRequest.notifyListeners memberi tahu UI bahwa sesi aktif. Logout kebalikannya: Flutter memanggil endpoint logout sehingga Django menghapus session server-side dan CookieRequest membersihkan cookie lokal. Setelah itu UI kembali ke halaman login karena status loggedIn kembali false.
### Step by Step mengerjakan checklist
    Setelah memastikan deployment Django di i-wear-soccer berjalan mulus, saya menyambungkan Flutter ke backend saya dengan membangun halaman registrasi di Flutter, lalu halaman login yang memakai CookieRequest buat ngobrol sama endpoint autentikasi Django. Begitu login berhasil, session cookie dari Django dipakai terus, jadi Flutter sekarang benar-benar terautentikasi terhadap server yang sama. Semua request selanjutnya (baik kirim produk maupun konsumsi JSON) menggunakan sesi ini. Di sisi model, saya membuat kelas Shop custom di Flutter sesuai struktur model Django (UUID, harga, kategori, dsb.) dan mengisi parser yang aman untuk menangani tipe data/null supaya sinkron dengan serializer Django.
    Dengan infrastruktur itu, saya buat layar daftar produk yang meng-fetch endpoint JSON yang sudah dideploy, lalu setiap kartu menampilkan atribut utama—name, price, description, thumbnail, category, dan is_featured. Kartu bisa diketuk untuk masuk ke halaman detail yang menampilkan semua atribut model, plus tombol balik ke daftar. Terakhir, saya tambahkan filter “My Products”: halaman list itu menerima flag dan hanya menampilkan item dengan user_id sama dengan pengguna yang sedang login ketika bernilai true (user ID diambil lewat endpoint current-user).
